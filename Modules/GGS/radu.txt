Tasks (cele indentate sunt closed)

	-cautarile indexate sa mearga si pt annotation matches
-sa se poata folosi js si din assertions - sa se seteze variabilele token si annotation inainte de a testa assertions, ca sa poata fi utilizate usor din contextul unui assertion state machine (atentie sa mearga si pt nested assertions toata treabaasta)
	-sa mearga nested assertions
	-de introdus macro-urile - niste prescurtari ce pot fi folosite oriunde in matching si annotation code, pt a face gramatica mai usor de citit. Utile in special la crossRef assertions. Exemplu: in assertion grammar, in loc de "<+id=$assertionToken.features.head$+postag=/Vm.*/>" sa faci un macro si sa scrii "<@HasHead@+postag=/Vm.*/>" - AR FI SUPER
	-macros replace in node on delete
-import macros
-sa se poata scoate la output doar informatie tabelara cumva... pt information extraction

-cand se consuma un annotation, in js, variabila, annotation sa preia valoarea ultimului annotation consumat (similar cu "token"). De introdus si variabila consumedItem care poate fi token sau annotation
-assertionToken ar trebui numit assertionItem si sa poata lua si valoare de annotation, pt atunci cand este consumat un annotation, nu un token. Sau si mai bine, sa lasam si assertionToken, si assertionItem si assertionAnnotation
-o metoda mai usoara de inserat assertions ca nu sta nimeni sa memoreze gozometi
-fix f9 issue - f9 merge doar cand e in focus grammareditorcomponent
-sa apara fereastra cu resultate in bara de jos ca e enervant asa.
-sa mearga cum trebuie pe mac (inclusiv zoom la pinch)
-vezi si zoom-ul

Future versions:
-warnings cand exista conflicte intre macro-uri. Daca un un macrou se termina cu un subsir cu care alt macrou incepe, sau daca un macrou include un alt macrou ca subsir, teoretic la aplicarea automata a acestora, ar putea aparea probleme. Macrouri cu acelasi nume.
-undo/redo la modificare de macro

	-de facut sa se poata lua ca input si text care are adnotari inline. Aici problema este la salvarea fisierului: nu o sa mai putem salva inline deoarece putem avea adnotari suprapuse. Ceea ce inseamna ca ne trebuie un nou format atat pt salvare, cat si pt citire care retine adnotarile intr-o maniera offset. Trebuie totusi sa suport si formatul folosit pana acum. Deci cand userul face save, va trebui sa aiba optiunea sa salveze inline doar daca a incarcat un fisier ce nu contine adnotari. Acest lucru trebuie permis si din engine jar.
Subtasks:

    -se poate incarca si salva intr-un format stand-off. Este in continuare un format flexibil. Un input text poate avea atat adnotari inline cat si adnotari stand-off. La salvarea adnotarilor create cu o retea GGS, daca input text avea adnotari, noile adnotari sunt salvate stand-off, altfel sunt salvate inline ca pana acum. Astfel maniera de integrare a lui GGS in eventuale lanturi de procesare existente nu necesita modificari (in cazul unei updatari a librariei)
    -am facut o componenta ui numita "AnnotationsExplorer" care vizualizeaza fisiere de input/output acceptate de GGS (cu adnotari atat inline cat si offset) cu optiuni de a afisa doar unele adnotari (filtrare dupa nume). Deasemenea, se pot selecta tokeni si adnotari pt a vedea atributele acestora intr-un panel lateral.
    -Componenta poate fi folosita si la afisarea rezultatelor in urma aplicarii unei retele folosind ggs editor. Componenta poate fi folosita ca un vizualiator de corpus complet independent de GGS.
    -sa se poata consuma adnotari intregi din noduri
    -de implementat consumarea tokenilor intregi (sa mearga si in lookbehind assertions)

    *componenta de afisare a rezultatelor trebuie sa evidentieze cumva adnotarile noi fata de cele din input
    -sa se poata pune conditia ca token-ul curent sa se afle intr-o adnotare de un anumit tip - am decis sa nu extind sintaxa in acest sens; se va putea face cu js
    -sa se poata testa daca un token este primul sau ultimul dintr-o adnotare - am decis sa nu extind sintaxa in acest sens; se va putea face cu js
    -de adus informatiile despre adnotarile din intrare si in spatiul javascript
    *de updatat documentatia GGS cu toate noutatile, de facut un tutorial
    *sa ghiceasca sentence tag name si in meniul f4
    *sa te avertizeze daca reteaua pune restrctie pe un atribut sau o valoare care nu exista in textul din input.
    *fix resize when nudge multiple nodes
    *sa te avertizeze daca vrei sa salvezi un document pe care nu s-au facut adnotari


	-se dau inapoi variabilele js cand se intoarce
	-tokenul curent este dat ca parametru pentru functia jsCode a nodurilor (variabila "token")
	-fa sa se poata folosi variabile js in expresii de matching
	-daca functia jsCode returneaza false sa nu se mearga pe acea ruta mai departe
	-cand rulezi din editor sa scrie si cat a durat
	-fa managementul variabilelor js pt apeluri recursive (deci, inainte sa se faca orice salt, bag intr-o stiva alocata graphului din care se sare, starea sa curenta. La intoarcere din salt, resetez valorile sale).
	-fa sa se poata folosi variabile js in expresii de output
	-sa se poata edita codul js la nivel de graph si grammar
	-fa sa apara frumos codul js in editor
	-desfiinteaza codul la nivel de gramatica. Daca cineva vrea sa initializeze ceva, poate sa o faca dintr-un nod care ruleaza doar o data la inceput in Main... keep it simple
	-scoate variabilele la nivel de nod. Lasa doar la nivel de graph si grammar. Fiecare nod devine o functie care nu mai are nevoie de clonare. Se pot folosi variabile de graf sau gramatica in loc de variabile de nod
	-fa posibilitatea de a da parametri unui graf (ce idee grozava!). Spre exemplu sa se poata face salturi de genul :nounPhrase(oblique) astfel facanduse jump catre graful nounPhrase. Valorea parametrilor dati se va putea accesa din codul js al grafului folosind expresia parameters[i].
	-scoate codul la nivel de graph - se poate baga cod in nodul de start
	-argumentele sa fie inserate in momentul call-ului ca obiecte locale sub numele "arguments" dar si ca obiect global "arguments"
	-la intoarcerea din jump, trebuie modificata valoarea lui "graph", si a lui "arguments"
	-daca un graph nu contine niciun nod care sa aiba cod js atunci sa nu se mai faca toate operatiile de clonare js la fiecare pas al parcurgerii prin acel graf.
	-codul js sa se aplice dupa ce s-a potrivit matching pattern, iar grafic acest lucru sa fie de inteles (adica de modificat aspectul cutiei cu cod js)
	-scoate limita de recurenta - este o chestiune avansata, iar cine chiar vrea sa o faca o poate face folosind variabile js
	-scoate tot pannelul de jos. De acolo se seteaza doar priority policy acum. O sa mutam asta in fereastra de dublu click pe nod
	-userul sa poata "minimiza" cutia cu cod js
	-fa sa mearga stop cand parseaza (si sa afiseze rezultatele obtinute pana atunci)
	-fa sa se poata face scroll pt grafuri mai mari
	-daca un nod empty fara cod js sau alte chestii leaga (este punte intre) un nod care are un sg copil (acest nod empty) de un alt nod care are un sg parinte (tot acest nod empty), atunci pathurile sa fie desenate mai continuu, mai frumos. ca o curba continua
	-editarea codului js trebuie sa fie undo-able
	-vezi daca mai merg parametrii	
	-variabilele js ar trebui sa fie colorate frumos
	-cand da syntax error in js sa iti arate nodul cu problema...
	-fa sa te intrebe daca vrei sa salvezi cand iesi
	-comentarii in ggs (noduri de tip comment)
	-sa se aprinda cu rosu pe loc cand nu e ok codul ggs pt output sau token matching
	-ar trebui deasemenea de verificat daca totul este in regula cu adnotarile imbricate, daca exista posibilitatea ca vreo adnotare sa ramana deschisa

	-sa crape la compilare cu un mesaj frumos pt
			cod formatat prost
			eroare la rularea codului js
			eroare la evaluarea unei variabile
			eroare la un jump catre un graph inexistent
			eroare la evaluarea argumentelor unui jump
			bucle infinite
			adnotari neinchise
			posibilitatea de a potrivi 0 simboluri
			assertions care nu au nod termminal
		
	-vezi toate TODOs de prin cod	
	-repara copacul din dreapta ca are tot felul de bugs
	-sa te intrebe daca vrei sa salvezi cand dai new sau open - inclusiv cand faci open cu drag and drop
	-fix: cand se seteaza alt inferrer grammar, el tot pe Main il considera inferrer
	-relative paths pt input file din run configuration
	-repara shouldSave cand se umbla la	run config
	-show error la open
	-ce se intampla cu path priorities cand sunt assertions pe acolo? Sa nu mai apara path order box spre assertions
	-also consider js boxes when drawing grammar frame
	-js boxes sa stea in fata
	-sa te intrebe daca vrei sa salvezi peste, cand salvezi o gramatica sau un output
	-move nodes merge foarte incet pe vechea gramatica de np - de ce? - pt ca se facea refresh tree la fiecare mishcare a mouse-ului... si fiind o gramatica cu multe graphs...
	-dublu click pe js bullet face nod nou - scoate asta
	-disable token matching code pt start and finish nodes
	-disable output matching code si js code si priority policy cand e comment node
	-js variables in assertions - in look behind assertions le vede?
	-testeaza toate tutorialele
	-annotations care au 0 tokeni... ce facem cu ele? le lasam? dar merg? le sterg
	-nudge nodes cu sageti - fa si undoable
	-sa mearga din linia de comanda
	-scrie citations	
	-codul js sa fie rulat dupa ce se face match - de modificat si tutorialele.
	-cand se face propozitia in js, trebuiesc tratate caracterele speciale ()[]{}"\\ etc


-userul sa poata marca acele noduri care au cod js ce nu face modificari (ci doar pune conditii) pt a eficientiza motorul
-mai trebuie testata functia care cauta bucle infinite si path-uri goale ca uneori arunca erori false (spre ex pe gramatica NP veche parca crapa)
-sa dea un warn cand nu s-a gasit nici-o propozitie in input (poate nu e corect sentence tag-ul dat)
-sa arate un progres ceva cand cauta
-cand faci browse pt input text sa porneasca de la folderul pt input text-ul curent, daca exista

?-sa nu se mai cloneze toate obiectele ci doar variabilele locale curente si variabilele globale
?-sa nu se mai poata accesa variabile locale din alte grafuri. scoate si din documentatie acest lucru!!!
	
Future Features
-sa se poata vedea pt un match pathul pe care s-a potrivit (buclele sa se vada frumos si sa apara tokenii consumati in dreptul nodurilor). Pt asta trebuie implementata o metoda de a marca un path. Aceasta ar putea fi folosita si pt a indica bucle infinite, pathuri empty si altele
-la rezultate sa se vada outputul dispus ca un tree
-scade f mult timpul de la o rulare la alta; probabil e din cauza ca niste liste/mape/memoria jvm isi maresc capacitatea, rezultand in mai putine operatii la urmatoarea rulare.
-grupari de noduri (ca sa se miste impreuna)
-la compilare ar fi fain daca am mai reduce numarul de stari. Sunt multe stari din noduri <E> fara cod js care sunt inutile si incetinesc procesul




ADVERTISING
Cand am o versiune stabila, cu documentatie riguroasa, o trimit la tot grupul NLP. O trimit si in lista de la nooj. Rog lumea sa dea mai departe daca le place. Rog lumea sa ma ajute sa construim o comunitate. Rog lumea sa imi dea feedback si idei.


---------------chestii care ar fi fain de implementat
-un fel de afisare frumoasa care sa arate drumul pe care a mers cand a descoperit un anumit match.
-un fel de debugging: sa se poata face break pe un anumit nod, sa se poata da resume sau step, sa se poata vedea tot felul de valori (input stack, sofar match etc)
-un debugging si mai extins in care sa se poata da break inclusiv pe linii de cod js, cu watch pe variabile js etc
-posibilitatea de a importa jaruri si de a le folosi din cod js - poate cineva vrea sa foloseasca o anume librarie
-validarea gramaticii xml
-validarea asertiunilor in timp real


---------------despre containerele de variabile

-Avem containerul global. Acesta nu este refacut la backtracking. E bun pt numarat cuvinte, adnotari etc
-Avem containerul grammar. Acesta este rafacut la backtracking - adica daca o valoare se schimba la un nod, cand firul de executie se intoarce, acea valoare revine la valoare initiala (asta include stergerea ei, etc)
-Avem cate un container numit graph_nume pt fiecare graf din gramatica. Variabilele acestora sunt refacute la back tracking. Folosite in special pt a verifica gramatical agreements. Spre deosebire de grammar, aceste variabile pot fi ascunse de apeluri recursive.
-(ramane de vazut daca mai au rost aceste containere) Mai exista si cate un container pt fiecare nod din care se executa cod js. Acestea pot fi accesate de oriunde astfel grammar.graph_nume.node_numar desi scopul lor este de a nu fi accesate astfel, ci direct, din codul de matching sau de output al nodului curent

-cum poate userul sa scrie cod care este rulat o sg data per sentence? dar per token? Dar per input text? Raspuns: poate crea variabile care sa marcheze ca pt o anumita propozitie sau token, codul a fost rulat, la nodul de start al gramaticii. Acestea ar trebui puse in contextul grammar, deoarece restul sunt resetate automat cand se trece de la un token la altul
sau, poate extinde instantele obiectelor token si sentence pt a marca cumva faptul ca au fost parcurse
---------------

Cum fac variabile in GGS? Dupa multe incercari si cautari am ajuns la urmatoarea forma finala.
Am decis sa folosesc cod javascript pt posibilitatea de a rula script in cadrul aplicarii unei gramatici.
Utilizatorul poate adauga cod js unui nod sau graf din interfata ggs. Un nod are acum 3 campuri ce pot fi completate.
1)Pattern matching code pt consumat tokeni
2)output code pt facut adnotari pe tokenii consumati
3)codul js pt scris cod js care sa fie rulat

Variabilele sunt de doua tipuri. Globale (la nivel de gramatica) si locale (la nivel de graph). In cadrul spatiului de programare javascript GGS construieste si foloseste niste containere (scripting contexts) pentru variabile si cod js care sunt completate de catre utilizator prin interfata de editare. Astfel exista un container pt gramatica, numit "grammar" care este un obiect js ca oricare altul. In acelasi mod exista si cate un obiect js pt fiecare graf, avand numele de tipul graph_numeGraf. Aceste obiecte au implicit definita metoda jsCode() al carei cod este in totalitate completat de catre utilizator. Fiecare graph poate avea alt cod in cadrul acestei functii. Aceasta functie este complet transparenta utilizatorului. Nu i se spune ca scriptul pe care il scrie el este bagat intr-o functie. El doar deschide un textbox din editor in care poate scrie, daca doreste, cod js. Metoda jsCode a unui graf este rulata in momentul in care parserul intra in nodul de start al acestuia. Deasemenea aceasta metoda primeste si parametri dar mai tarziu explic care e treaba cu ei. Mai intai despre codul la nivel de nod
La nivel de nod, ca si la grafuri, exista cate o functie pt fiecare nod care este rulata cand parserul ajunge la acesta. Codul rulat de aceste functii este completat de utilizator. Din nou, mecanismul prin care GGS ruleaza acest cod este complet invizibil utilizatorului. Din acest spatiu se pot accesa variabilele de la nivel de graf si grammar. Iata niste exemple
	grammar.variabila_mea = "ceva"; //declarare sau modificare de variabila globala
	graph_numeGraphParinte.variabila_mea_locala = "altceva"
De notat ca graph_numeGraphParinte poate fi acesat si simplu prin variabila "graph" (aceasta refera intotdeauna graful parinte/curent pentru simplitate in scriere). Din cadrul codului unui nod sau graf se poate accesa contextul de scriptare al oricarui graf. Codul js de la nivelul nodurilor poate fi folosit inclusiv pentru a nu lasa motorul de parsare sa mai continue pe un anume drum (de obicei cand se indeplineste o conditie). Acest lucru se intampla daca functia returneaza false (altfel returneaza true implicit).

Spuneam ca grafurile pot primi si parametri. Se poate acum face un salt folosind urmatorul cod GGS   :NP("oblique")
Parametrii pot fi accesati doar din codul de la nivel de graf. Pentru a acesa argumentul 0 pt acest exemplul, in codul grafului NP se poate scrie 
graph.case = parameters[0];
urmand ca graph.case sa fie folosit in alte noduri ale lui NP pt a face graful sa nu accepte decat np-uri avand caz oblic.

Variabilele ggs pot fi folosite si din codul care potriveste tokeni astfel:
<+MSD=/Nc.*/+Case=$graph.case$>
In acelasi fel pot fi folosite si din limbajul folosit pt a adnota tokenii consumati:
<NP+case=$graph.case$


Dificultatile majore la implementare au fost urmatoarele:
-Cum sa facem restore la variabile atunci cand firul de executie trebuie sa faca backtraking? Am folosit o stiva de clone ale tuturor containerelor. Se face push inainte de a rula orice cod. Iar la intoarcere se face pop. Dificultatea aici a fost gasirea unei metode generice de clonare de obiecte. Avand in vedere ca userul poate practic sa foloseasca intreaga gama de features ale poo si ale programarii functionale oferita de javascript. Din acest motiv clonarea generica este aproape imposibila dar am gasit o metoda care sa rezolve marea majoritate a cazurilor obiectelor. (nota: Probleme raman in cazul ierarhiilor de prototipuri sau a variabilelor private. Acestea sunt deja chestiuni avansate in js pe care userul nu prea ar trebui sa aiba nevoie sa le foloseasca)
-Sa zicem ca avem un graf in care firul de parsare merge astfel prin noduri: la un moment dat se creaza o variabila locala, undeva pe traseu i se modifica valoarea, apoi se face un salt recursiv catre acelasi graf. In acest moment o noua variabila cu acelasi nume trebuie sa o ascunda pe cea veche, pentru ca atunci cand se intoarce firul de executie din recursie, variabile veche sa redevina vizibila, avand. Acest lucru am reusit sa il obtin folosind cate o stiva de clone backups pt fiecare graph in parte. Aceste stive sunt updatate cand se face un salt sau cand se revine din salt.